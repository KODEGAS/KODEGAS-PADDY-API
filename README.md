# KODEGAS Paddy API: AI-Powered Disease Detection for Rice Crops

This repository hosts the backend API for the KODEGAS Paddy disease detection system. Leveraging a trained TensorFlow model, this API provides robust capabilities for identifying diseases in paddy crops from images, alongside comprehensive management of disease information and recommended treatments. It's designed to be a reliable and scalable solution for agricultural insights.

## Key Features

-   **Intelligent Disease Prediction:** Upload an image of a paddy leaf to receive an accurate disease prediction and confidence score, powered by a deep learning model.
-   **Comprehensive Disease Information:** Access detailed insights into various paddy diseases, including their symptoms, causes, and effective prevention strategies.
-   **Tailored Treatment Recommendations:** Obtain a prioritized list of recommended medicines and treatments for specific diseases, aiding in effective crop management.
-   **Dynamic Data Management (CRUD):** Utilize a secure, web-based interface for seamless Create, Read, Update, and Delete (CRUD) operations on disease information and medicine data.
-   **Containerized Deployment:** The entire application is encapsulated within a Docker container, ensuring consistent and straightforward deployment across different environments.
-   **Robust Health Monitoring:** A dedicated `/health` endpoint provides real-time status updates, allowing for continuous service monitoring.
-   **Advanced Image Processing:** Includes sophisticated image processing capabilities for optimal model input, handling resizing, compression, and aspect ratio preservation.

## Project Structure

```
.
├── Dockerfile                  # Defines the Docker image for containerized deployment
├── LICENSE                     # Project licensing information
├── README.md                   # This comprehensive guide to the project
├── auth.py                     # API key authentication logic
├── deployment_guide.md         # Detailed instructions for deploying the API
├── disease_info.json           # Stores detailed information about various paddy diseases
├── disease_medicines.json      # Contains recommended medicines for each disease
├── image_processor.py          # Handles image validation, processing, and compression
├── labels.txt                  # List of disease class names for model predictions
├── main.py                     # The core FastAPI application with all API endpoints
├── mymodel                     # Directory containing the trained TensorFlow SavedModel
│   ├── saved_model.pb          # TensorFlow model graph definition
│   └── variables               # Model weights and variables
│       ├── variables.data-00000-of-00001
│       └── variables.index
├── openapi.json                # OpenAPI specification for the API (auto-generated by FastAPI)
├── requirements.txt            # Python dependencies required for the project
├── static                      # Static files for the web interface
│   ├── api_data.html           # Main web interface for API data interaction
│   ├── disease_info_crud.html  # CRUD interface for disease information
│   ├── favicon.ico             # Website favicon
│   └── medicine_info_crud.html # CRUD interface for medicine information
├── test_image.jpg              # Sample image used for testing purposes
└── test_image_processing.py    # Script for testing image processing and prediction endpoints
```

## API Endpoints

For a complete and interactive overview of all available API endpoints, their parameters, and responses, please refer to the automatically generated OpenAPI documentation (Swagger UI) at `/docs` when the application is running.

### Core Endpoints

-   `POST /predict`: Upload an image file (`multipart/form-data`) to receive a disease prediction, confidence score, and image metadata.
-   `GET /disease-info/{name}`: Retrieve comprehensive details about a specific paddy disease by its name (e.g., `blast`, `bacterial_leaf_blight`).
-   `GET /disease-medicines?name={name}`: Get a prioritized list of recommended medicines and treatments for a given disease.
-   `GET /health`: A simple health check endpoint to verify the API's operational status.
-   `POST /process-image`: Process and compress an image without making predictions, useful for testing image processing capabilities.
-   `GET /image-processing-info`: Get information about image processing capabilities and limits.

### Secure CRUD Endpoints

The API provides a full suite of CRUD endpoints for managing the `disease_info.json` and `disease_medicines.json` datasets. These endpoints are primarily utilized by the static web interface and require API key authentication.

-   `/medicines/*`: Endpoints for managing medicine entries for various diseases.
-   `/crud/disease-info/*`: Endpoints for managing detailed disease information.

## Getting Started

### Prerequisites

Ensure you have the following installed on your system:

-   **Python 3.8+**: The core language runtime.
-   **`uv`**: A modern, fast Python package installer and resolver. If you don't have `uv`, you can install it via `pip`: `pip install uv`.
-   **Docker**: (Optional, but recommended for deployment) For building and running the application in containers.

### Local Development Setup

Follow these steps to set up and run the API locally:

1.  **Clone the repository:**

    ```bash
    git clone https://github.com/kavindus0/KODEGAS-PADDY-API.git
    cd KODEGAS-PADDY-API
    ```

2.  **Create and activate a Python virtual environment:**

    ```bash
    python3 -m venv .venv
    source .venv/bin/activate
    ```

3.  **Install project dependencies using `uv`:**

    ```bash
    uv pip install -r requirements.txt
    ```

4.  **Run the FastAPI application:**

    ```bash
    uvicorn main:app --host 0.0.0.0 --port 8000
    ```

    Once the server starts, the API will be accessible at `http://localhost:8000`. You can explore the interactive API documentation (Swagger UI) by navigating to `http://localhost:8000/docs` in your web browser.

### Dockerized Deployment

For production deployments, using Docker is highly recommended for consistency and isolation:

1.  **Build the Docker image:**

    ```bash
    docker build -t kodegas-paddy-api .
    ```

2.  **Run the Docker container:**

    ```bash
    docker run -d -p 8000:8000 --name paddy-api kodegas-paddy-api
    ```

    The API will then be available at `http://your-server-ip:8000`.

## Security Considerations

The CRUD endpoints (`/medicines/*` and `/crud/disease-info/*`) are secured using API key authentication. To interact with these endpoints, you must include a valid API key in the `X-API-Key` header of your HTTP requests.

**Important:** For production environments, it is crucial to use a strong, securely generated API key and manage it through environment variables or a dedicated secrets management service. Avoid hardcoding API keys directly in your application code.

When accessing the web interface, you will be prompted to enter the API key for protected actions. This key is stored in your browser's session storage for convenience during your session.

## Web Interface

The application includes a user-friendly web interface for managing the underlying data, accessible at `/static/api_data.html`. This interface provides:

-   **Medicine Management:** A comprehensive CRUD interface for adding, editing, and deleting medicine information associated with each disease.
-   **Disease Information Management:** A dedicated CRUD interface for updating and maintaining detailed information for each disease entry.

## Data and Model Assets

-   **`mymodel/`**: Contains the pre-trained TensorFlow SavedModel used for disease prediction.
-   **`labels.txt`**: Defines the class names (disease types) that the model is trained to predict.
-   **`disease_info.json`**: A JSON file storing structured, detailed information about each paddy disease.
-   **`disease_medicines.json`**: A JSON file containing curated lists of recommended medicines and treatments, organized by disease.

## Contributing

We welcome contributions to enhance the KODEGAS Paddy API! If you have suggestions, bug reports, or would like to contribute code, please feel free to open an issue or submit a pull request on our GitHub repository.

## License

This project is open-source and licensed under the terms specified in the [LICENSE](LICENSE) file.
